<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON to TypeScript & Zod Generator: Complete Guide for Type-Safe Code (2026)</title>
    <meta name="description"
        content="Master JSON to TypeScript conversion with our comprehensive guide. Learn type inference, Zod validation schemas, runtime safety, and production best practices for TypeScript developers.">
    <meta name="keywords"
        content="json to typescript, json to zod, typescript generator, type inference, zod schema, runtime validation, typescript interfaces, type safety, zod validation, typescript types from json">
    <meta name="author" content="Code Formatter">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="canonical" href="https://www.codeformatter.in/blog-json-to-typescript.html">
    <meta property="og:title" content="JSON to TypeScript & Zod Generator: Complete Developer Guide">
    <meta property="og:description"
        content="Learn JSON to TypeScript conversion with Zod schemas for runtime validation. Complete guide with examples and best practices.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://www.codeformatter.in/blog-json-to-typescript.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="JSON to TypeScript & Zod Generator Guide">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        :root {
            --bg-body: #09090b;
            --bg-card: rgba(24, 24, 27, 0.6);
            --bg-code: #121214;
            --border: #27272a;
            --border-highlight: #3f3f46;
            --primary: #818cf8;
            --primary-glow: rgba(129, 140, 248, 0.15);
            --secondary: #10b981;
            --danger: #f87171;
            --warning: #fbbf24;
            --text-main: #e4e4e7;
            --text-muted: #a1a1aa;
            --text-dim: #71717a;
            --font-ui: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-code: 'JetBrains Mono', monospace
        }

        * {
            box-sizing: border-box
        }

        body {
            background-color: var(--bg-body);
            background-image: linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 30px 30px;
            color: var(--text-main);
            font-family: var(--font-ui);
            line-height: 1.6;
            margin: 0;
            padding: 0;
            -webkit-font-smoothing: antialiased;
            overflow-x: hidden
        }

        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: transparent;
            z-index: 1000
        }

        .progress-bar {
            height: 3px;
            background: var(--primary);
            width: 0;
            box-shadow: 0 0 10px var(--primary);
            transition: width 0.1s
        }

        .wrapper {
            max-width: 760px;
            margin: 0 auto;
            padding: 40px 20px 120px 20px;
            position: relative
        }

        .nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 15px
        }

        .nav-back {
            color: var(--text-muted);
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: color 0.2s
        }

        .nav-back:hover {
            color: #fff
        }

        .brand-logo {
            font-weight: 700;
            color: #3b82f6;
            text-decoration: none;
            font-size: 0.9rem;
            letter-spacing: -0.5px
        }

        article h1 {
            font-size: 2.4rem;
            font-weight: 800;
            letter-spacing: -0.03em;
            line-height: 1.2;
            margin: 0 0 15px 0;
            background: linear-gradient(180deg, #fff, #a1a1aa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent
        }

        .meta-row {
            display: flex;
            gap: 20px;
            font-size: 0.8rem;
            color: var(--text-dim);
            font-family: var(--font-code);
            margin-bottom: 35px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 20px;
            flex-wrap: wrap
        }

        .meta-row span {
            display: flex;
            align-items: center;
            gap: 6px
        }

        .meta-row i {
            color: var(--primary)
        }

        article p {
            font-size: 1.05rem;
            color: #d4d4d8;
            margin-bottom: 20px
        }

        article h2 {
            font-size: 1.7rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            color: #fff;
            margin-top: 50px;
            margin-bottom: 20px;
            position: relative;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border)
        }

        article h2::before {
            content: '#';
            color: var(--primary);
            opacity: 0.4;
            margin-right: 8px
        }

        article h3 {
            font-size: 1.3rem;
            font-weight: 600;
            color: #fff;
            margin-top: 35px;
            margin-bottom: 12px
        }

        strong {
            color: #fff;
            font-weight: 700
        }

        ul,
        ol {
            margin-bottom: 24px;
            padding-left: 20px;
            color: var(--text-muted)
        }

        li {
            margin-bottom: 8px
        }

        code {
            background: rgba(129, 140, 248, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
            font-family: var(--font-code)
        }

        pre {
            background: var(--bg-code);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: var(--font-code);
            font-size: 0.9rem;
            line-height: 1.6
        }

        pre code {
            background: none;
            padding: 0
        }

        .cta-box {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 12px;
            padding: 30px;
            margin: 40px 0;
            text-align: center
        }

        .cta-box h3 {
            margin-top: 0;
            color: #fff
        }

        .cta-box p {
            color: var(--text-muted);
            margin-bottom: 20px
        }

        .cta-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: var(--primary);
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.2s
        }

        .cta-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(129, 140, 248, 0.3)
        }

        .faq-section {
            margin-top: 60px
        }

        .faq-item {
            background: rgba(24, 24, 27, 0.6);
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 12px;
            overflow: hidden;
            transition: all 0.2s
        }

        .faq-item:hover {
            border-color: var(--border-highlight);
            background: rgba(32, 32, 35, 0.7)
        }

        .faq-question {
            padding: 18px 20px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1.05rem;
            color: #fff;
            list-style: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none
        }

        .faq-question::-webkit-details-marker {
            display: none
        }

        .faq-icon {
            color: var(--primary);
            font-size: 1.3rem;
            font-weight: 300;
            transition: transform 0.3s ease;
            min-width: 20px;
            text-align: center
        }

        .faq-item[open] .faq-icon {
            transform: rotate(45deg)
        }

        .faq-answer {
            padding: 0 20px 20px 20px;
            color: var(--text-muted);
            font-size: 0.98rem;
            line-height: 1.7;
            animation: fadeIn 0.3s ease-in-out
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-5px)
            }

            to {
                opacity: 1;
                transform: translateY(0)
            }
        }

        .faq-answer strong {
            color: #fff
        }

        .faq-answer code {
            background: rgba(129, 140, 248, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em
        }

        footer {
            margin-top: 80px;
            padding: 30px 0;
            border-top: 1px solid var(--border);
            background: rgba(24, 24, 27, 0.4);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px)
        }

        .footer-content {
            text-align: center;
            max-width: 760px;
            margin: 0 auto;
            padding: 0 20px
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin-bottom: 15px;
            flex-wrap: wrap
        }

        .footer-links a {
            color: var(--primary);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px
        }

        .footer-links a:hover {
            color: #fff;
            transform: translateY(-2px)
        }

        .footer-copyright {
            font-size: 0.85rem;
            color: var(--text-dim);
            margin: 0
        }

        @media(max-width:600px) {
            .wrapper {
                padding: 20px 15px 100px 15px
            }

            article h1 {
                font-size: 1.8rem
            }

            article h2 {
                font-size: 1.4rem
            }

            pre {
                padding: 15px;
                font-size: 0.8rem
            }
        }
    </style>

    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": "JSON to TypeScript & Zod Generator: Complete Guide for Type-Safe Code",
        "description": "Master JSON to TypeScript conversion with our comprehensive guide. Learn type inference, Zod validation schemas, and production best practices.",
        "author": {
            "@type": "Organization",
            "name": "Code Formatter"
        },
        "publisher": {
            "@type": "Organization",
            "name": "Code Formatter"
        },
        "datePublished": "2026-01-04",
        "dateModified": "2026-01-04"
    }
    </script>
</head>

<body>
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <div class="wrapper">
        <nav class="nav-header">
            <a href="blog.html" class="nav-back"><i class="fas fa-arrow-left"></i> All Articles</a>
            <a href="index.html" class="brand-logo">Code Formatter</a>
        </nav>

        <article>
            <h1>JSON to TypeScript & Zod Generator: Complete Guide for Type-Safe Code (2026)</h1>

            <div class="meta-row">
                <span><i class="far fa-user-circle"></i> Code Formatter Team</span>
                <span><i class="far fa-calendar-alt"></i> Jan 4, 2026</span>
                <span><i class="far fa-clock"></i> 12 Min Read</span>
            </div>

            <p>Converting <strong>JSON to TypeScript types</strong> is one of the most common tasks in modern web
                development. Every API response, configuration file, and data structure needs proper type definitions
                for type-safe development. But manually typing complex JSON structures is tedious, error-prone, and
                time-consuming. That's where JSON to TypeScript generators become essential tools in every developer's
                workflow.</p>

            <p>This comprehensive guide covers everything you need to know about <strong>JSON to TypeScript
                    conversion</strong>, including type inference strategies, <strong>Zod validation schemas</strong>
                for runtime safety, and production best practices used by senior engineers at top tech companies.</p>

            <h2>Understanding JSON to TypeScript Conversion</h2>

            <p><strong>JSON to TypeScript conversion</strong> is the process of analyzing JSON data structures and
                generating corresponding TypeScript type definitions. TypeScript provides compile-time type checking,
                catching errors in your IDE before code execution. This dramatically reduces bugs and improves developer
                experience with features like autocomplete and inline documentation.</p>

            <p>However, TypeScript types are <strong>erased at runtime</strong>. After compilation to JavaScript, no
                type information exists. This means TypeScript cannot protect your application from malformed data
                received from external sources like APIs, user input, or third-party services. That's where
                <strong>Zod</strong> enters the equationâ€”providing runtime validation that TypeScript cannot.</p>

            <h3>Why Generate Types Instead of Writing Manually?</h3>

            <ul>
                <li><strong>Speed:</strong> Generate types for complex 500-line JSON responses in seconds instead of
                    hours</li>
                <li><strong>Accuracy:</strong> Eliminate human errors from manual type transcription</li>
                <li><strong>Consistency:</strong> Ensure types exactly match actual data structure</li>
                <li><strong>Maintainability:</strong> Regenerate types when API contracts change</li>
                <li><strong>Documentation:</strong> Generated types serve as living documentation of data structures
                </li>
            </ul>

            <h2>TypeScript Type Generation Explained</h2>

            <p>When you paste JSON into a type generator, an intelligent <strong>type inference engine</strong> analyzes
                every value and creates appropriate TypeScript definitions:</p>

            <h3>Primitive Type Detection</h3>

            <p>The generator examines each value's JavaScript type and maps it to TypeScript:</p>

            <pre><code>// JSON Input
{
  "name": "John Doe",      // string
  "age": 28,               // number
  "isActive": true,        // boolean
  "lastLogin": null        // null (often = optional)
}

// Generated TypeScript
interface User {
  name: string;
  age: number;
  isActive: boolean;
  lastLogin?: null;  // Optional due to null value
}</code></pre>

            <h3>Array Type Inference</h3>

            <p>Arrays are analyzed to determine their element types. Homogeneous arrays get typed directly; mixed arrays
                become union types:</p>

            <pre><code>// Homogeneous array
"tags": ["react", "typescript"]  â†’  tags: string[]

// Object array
"users": [{"id": 1}, {"id": 2}]  â†’  users: User[]

// Mixed array (rare)
"mixed": [1, "hello", true]  â†’  mixed: (number | string | boolean)[]</code></pre>

            <h3>Nested Object Handling</h3>

            <p>Complex JSON with deeply nested objects generates separate interfaces for each level, maintaining clean,
                readable code:</p>

            <pre><code>// Generated interfaces for nested JSON
interface Root {
  user: User;
  settings: Settings;
}

interface User {
  id: number;
  profile: Profile;
}

interface Profile {
  avatar: string;
  bio: string;
}</code></pre>

            <div class="cta-box">
                <h3>ðŸš€ Try Our JSON to TypeScript Generator</h3>
                <p>Paste your JSON and instantly generate TypeScript interfaces or Zod schemas. 100% free, 100%
                    client-side.</p>
                <a href="json-to-typescript.html" class="cta-btn"><i class="fas fa-code"></i> Generate Types Now</a>
            </div>

            <h2>Zod Schema Generation for Runtime Validation</h2>

            <p>While TypeScript catches errors at compile-time, <strong>Zod provides runtime
                    validation</strong>â€”essential for any production application that receives external data. When you
                fetch data from an API, you're trusting that the response matches your types. But APIs can change, bugs
                can occur, and malicious actors can send unexpected data.</p>

            <h3>The Runtime Validation Problem</h3>

            <pre><code>// This compiles fine, but crashes at runtime if response is malformed
const response = await fetch('/api/user');
const user: User = await response.json();
console.log(user.name.toUpperCase());  // TypeError if name is undefined!</code></pre>

            <h3>Zod Solution</h3>

            <pre><code>// Zod validates at runtime before your code touches the data
const UserSchema = z.object({
  name: z.string(),
  email: z.string().email(),
  age: z.number().min(0)
});

const response = await fetch('/api/user');
const rawData = await response.json();
const user = UserSchema.parse(rawData);  // Throws detailed error if invalid
// Now 'user' is guaranteed to match the schema</code></pre>

            <h3>Smart Validation Generation</h3>

            <p>Quality type generators detect common patterns and add appropriate Zod validations:</p>

            <ul>
                <li>Strings containing "@" â†’ <code>z.string().email()</code></li>
                <li>Strings starting with "http" â†’ <code>z.string().url()</code></li>
                <li>Null values â†’ <code>.optional()</code> or <code>.nullable()</code></li>
                <li>Arrays â†’ <code>z.array(itemSchema)</code> with nested schema references</li>
            </ul>

            <h2>Best Practice: Single Source of Truth</h2>

            <p>The most robust approach is using Zod schemas as your single source of truth, then inferring TypeScript
                types from them:</p>

            <pre><code>import { z } from 'zod';

// Define Zod schema (runtime)
export const UserSchema = z.object({
  id: z.number(),
  email: z.string().email(),
  name: z.string(),
  createdAt: z.string().datetime()
});

// Infer TypeScript type (compile-time)
export type User = z.infer&lt;typeof UserSchema&gt;;

// Usage
async function fetchUser(id: number): Promise&lt;User&gt; {
  const response = await fetch(`/api/users/${id}`);
  const data = await response.json();
  return UserSchema.parse(data);  // Validated + typed!
}</code></pre>

            <p>This pattern ensures your runtime validation and compile-time types <strong>can never drift out of
                    sync</strong>â€”changes to the schema automatically update the type.</p>

            <h2>When to Use TypeScript vs Zod</h2>

            <h3>Use TypeScript Interfaces When:</h3>
            <ul>
                <li>Typing internal application state that you fully control</li>
                <li>Defining function parameter and return types</li>
                <li>Creating complex generic types and utilities</li>
                <li>Documenting code structure for team collaboration</li>
            </ul>

            <h3>Use Zod Schemas When:</h3>
            <ul>
                <li>Validating external API responses before processing</li>
                <li>Handling user form input and submissions</li>
                <li>Parsing configuration files at startup</li>
                <li>Processing webhook payloads from third-party services</li>
                <li>Reading environment variables with type safety</li>
            </ul>

            <h2>Production Best Practices</h2>

            <h3>1. Use Representative Sample Data</h3>
            <p>Generate types from production-like JSON, not minimal examples. If fields can be <code>null</code> in
                production but your sample has values, manually adjust optionality.</p>

            <h3>2. Review and Enhance Generated Code</h3>
            <p>Generators make best-effort inferences. Add JSDoc comments, refine optional fields, add custom Zod
                refinements, and split large types into smaller pieces based on domain knowledge.</p>

            <h3>3. Version Control Your Types</h3>
            <p>Commit generated type files to track API contract evolution. Review type changes in pull
                requestsâ€”unexpected type changes often indicate API breaking changes.</p>

            <h3>4. Use TypeScript Utility Types</h3>
            <pre><code>// Create variations for different use cases
type CreateUserInput = Omit&lt;User, 'id' | 'createdAt'&gt;;
type UpdateUserInput = Partial&lt;Omit&lt;User, 'id'&gt;&gt;;
type UserSummary = Pick&lt;User, 'id' | 'name' | 'email'&gt;;</code></pre>

            <h3>5. Handle Errors Gracefully</h3>
            <pre><code>// Use safeParse for non-throwing validation
const result = UserSchema.safeParse(data);
if (!result.success) {
  console.error('Validation failed:', result.error.issues);
  return { error: 'Invalid user data' };
}
return { user: result.data };</code></pre>

            <h2>Common Integration Patterns</h2>

            <h3>React Hook Form + Zod</h3>
            <pre><code>import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

const form = useForm&lt;User&gt;({
  resolver: zodResolver(UserSchema)
});</code></pre>

            <h3>tRPC with Zod</h3>
            <pre><code>import { z } from 'zod';
import { router, publicProcedure } from './trpc';

export const userRouter = router({
  create: publicProcedure
    .input(UserSchema)
    .mutation(({ input }) => createUser(input))
});</code></pre>

            <h3>Next.js API Routes</h3>
            <pre><code>export default async function handler(req, res) {
  const result = UserSchema.safeParse(req.body);
  if (!result.success) {
    return res.status(400).json({ errors: result.error.issues });
  }
  // result.data is fully typed
}</code></pre>

            <h2>Frequently Asked Questions</h2>

            <div class="faq-section">
                <details class="faq-item">
                    <summary class="faq-question">
                        <strong>What's the difference between TypeScript interfaces and Zod schemas?</strong>
                        <span class="faq-icon">+</span>
                    </summary>
                    <div class="faq-answer">
                        <p><strong>TypeScript interfaces</strong> exist only at compile-time for static type checking in
                            your IDE and during compilation. They're erased completely at runtime. <strong>Zod
                                schemas</strong> exist at runtime and actively validate data, throwing errors for
                            invalid input. Use Zod for external data validation; use TypeScript for internal code
                            structure. Best practice: define Zod schemas and infer TypeScript types from them with
                            <code>z.infer</code>.</p>
                    </div>
                </details>

                <details class="faq-item">
                    <summary class="faq-question">
                        <strong>Can I convert TypeScript types to Zod schemas?</strong>
                        <span class="faq-icon">+</span>
                    </summary>
                    <div class="faq-answer">
                        <p>Not directlyâ€”TypeScript types don't exist at runtime, so there's nothing to convert. The
                            recommended approach is the reverse: define Zod schemas first, then infer TypeScript types
                            using <code>type T = z.infer&lt;typeof schema&gt;</code>. This makes Zod your source of
                            truth. Some tools like <code>ts-to-zod</code> can parse TypeScript source files and generate
                            equivalent Zod schemas, but this requires build-time processing.</p>
                    </div>
                </details>

                <details class="faq-item">
                    <summary class="faq-question">
                        <strong>How do I handle optional fields in generated types?</strong>
                        <span class="faq-icon">+</span>
                    </summary>
                    <div class="faq-answer">
                        <p>Generators typically mark fields with <code>null</code> values as optional
                            (<code>field?: type</code>) or nullable (<code>field: type | null</code>). However, JSON
                            samples don't always represent all possible states. Review generated types and manually
                            adjust optionality based on your API documentation or actual behavior. For Zod, use
                            <code>.optional()</code> for fields that may be missing and <code>.nullable()</code> for
                            fields that may be <code>null</code>.</p>
                    </div>
                </details>

                <details class="faq-item">
                    <summary class="faq-question">
                        <strong>Is Zod the only runtime validation library?</strong>
                        <span class="faq-icon">+</span>
                    </summary>
                    <div class="faq-answer">
                        <p>No, but it's the most popular choice for TypeScript projects. Alternatives include
                            <strong>Yup</strong> (older, widely used with Formik), <strong>io-ts</strong> (functional
                            programming style), <strong>Superstruct</strong> (lightweight), and <strong>Valibot</strong>
                            (smaller bundle size). Zod is preferred for its excellent TypeScript inference,
                            comprehensive API, and active community. Our generator focuses on Zod due to its industry
                            dominance.</p>
                    </div>
                </details>

                <details class="faq-item">
                    <summary class="faq-question">
                        <strong>Does generating types slow down my application?</strong>
                        <span class="faq-icon">+</span>
                    </summary>
                    <div class="faq-answer">
                        <p>Type generation is a <strong>development-time activity</strong> with zero runtime impact on
                            application performance. TypeScript types are completely erased during compilation. Zod
                            validation does add minimal runtime overhead (microseconds per validation), but this is
                            negligible compared to network latency and is essential for data safety. Our generator
                            processes everything client-side in your browserâ€”it never affects your deployed application.
                        </p>
                    </div>
                </details>

                <details class="faq-item">
                    <summary class="faq-question">
                        <strong>Can I use the generated code in production?</strong>
                        <span class="faq-icon">+</span>
                    </summary>
                    <div class="faq-answer">
                        <p>Absolutely! Generated code follows TypeScript best practices with proper exports, type
                            annotations, and Zod imports. However, treat it as a starting pointâ€”add JSDoc documentation,
                            refine optional fields based on actual API contracts, add custom Zod refinements (like
                            <code>.min()</code>, <code>.max()</code>), and consider splitting large types into smaller,
                            reusable pieces for better maintainability.</p>
                    </div>
                </details>

                <details class="faq-item">
                    <summary class="faq-question">
                        <strong>Is my JSON data secure when using online generators?</strong>
                        <span class="faq-icon">+</span>
                    </summary>
                    <div class="faq-answer">
                        <p>Our tool processes <strong>100% client-side</strong>â€”your JSON never leaves your browser. All
                            parsing and type generation happens locally using JavaScript. We don't collect, store, or
                            transmit any data. You can verify this in your browser's Network tabâ€”you'll see zero data
                            requests after the page loads. For sensitive production data, this client-side approach is
                            essential for security.</p>
                    </div>
                </details>
            </div>

            <div class="cta-box">
                <h3>ðŸŽ¯ Start Generating Type-Safe Code</h3>
                <p>Convert your JSON to TypeScript interfaces and Zod schemas instantly. No signup, no data collection.
                </p>
                <a href="json-to-typescript.html" class="cta-btn"><i class="fas fa-arrow-right"></i> Try the
                    Generator</a>
            </div>

            <p style="text-align:center;margin-top:3rem;color:#525252;font-size:0.85rem;">Code Formatter Â© 2026.
                Professional developer tools built with privacy and performance in mind.</p>
        </article>
    </div>

    <footer>
        <div class="footer-content">
            <div class="footer-links">
                <a href="index.html"><i class="fas fa-home"></i> Home</a>
                <a href="about.html"><i class="fas fa-info-circle"></i> About</a>
                <a href="privacy.html"><i class="fas fa-shield-alt"></i> Privacy</a>
                <a href="contact.html"><i class="fas fa-envelope"></i> Contact</a>
                <a href="blog.html"><i class="fas fa-blog"></i> Blog</a>
            </div>
            <p class="footer-copyright">Â© 2026 Code Formatter. All rights reserved.</p>
        </div>
    </footer>

    <script>
        window.addEventListener('scroll', () => { const winScroll = document.body.scrollTop || document.documentElement.scrollTop; const height = document.documentElement.scrollHeight - document.documentElement.clientHeight; const scrolled = (winScroll / height) * 100; document.getElementById("progressBar").style.width = scrolled + "%" });
    </script>
</body>

</html>